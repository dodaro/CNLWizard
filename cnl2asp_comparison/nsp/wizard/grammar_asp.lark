start: (proposition ".")+
%import common.WS 
%import common.CNAME 
%import common.SIGNED_NUMBER 
%import common.INT 
%import common.FLOAT 
%import common.NUMBER 
%import common.CPP_COMMENT 
%import common.LCASE_LETTER 
%ignore WS 
%ignore CPP_COMMENT 
?string: CNAME
?l_case: LCASE_LETTER
word: l_case string
?number: NUMBER

//  ----- Defined grammar below
quantified_choice_proposition: quantified_choice [for_each]
positive_constraint: "It is required that" positive_constraint_body ["," terminal_clause]
negative_constraint: "It is prohibited that" negative_constraint_body ["," terminal_clause]
preference: "It is preferred" "as much as possible"? ", with" level "priority, that" math "is minimized" ["," terminal_clause]
proposition: constant_definition | compounded_range_clause | quantified_choice_proposition | positive_constraint | negative_constraint | preference
attribute: "and"? "with" ("a " | "an ")? string [attribute_value] [comparison_operator attribute_value]
         | attribute "," attribute -> attribute_concat
verb: ("a" | "an")? word [attribute] word
attribute_value: string | number | sum_string | diff_string
when_clause: "when" simple_proposition_with_entities
terminal_clause: comparison_where_clause | between_where_clause | whenever_clause | whenever_aggregate | when_clause
               | terminal_clause "," terminal_clause -> terminal_clause_concat
whenever_aggregate: "whenever we have that" comparison
comparison_where_clause: "where" comparison
between_where_clause: "where" string "is between" (string | sum_string | diff_string) "and" (string | sum_string | diff_string)
sum_string: string "+" number
diff_string: string "-" number
math_first: string
math_second: string
!level: "low" | "medium" | "high"
positive_constraint_body: comparison | simple_proposition_with_entities
negative_constraint_body: comparison | simple_proposition_with_entities
comparison_first: simple_aggregate | passive_aggregate | string
comparison_second: number | string | sum_string | diff_string
for_each: "for each" entity
constant_definition: string "is a constant" ["equal to" number]
compounded_range_clause: ("A" | "An") string "goes from" (number | string) "to" (number | string)
quantified_choice: "Every" entity "can" ("be" | "have")? verb cardinality entity
cardinality: exactly | at_least | at_most | between
entity: ("a " | "an ")? string [attribute]
at_most: "at most" number
at_least: "at least" number
between: "between" number "and" number
exactly: "exactly" number
simple_aggregate: aggregate_operator string [string] "that" verb list_of_entities
list_of_entities: entity ("," "and"? entity)*
aggregate_operator: count | sum
whenever_clause: ("Whenever" | "whenever") "there is" [negation] entity
!comparison_operator: "equal to" | "different from" | "less than" | "greater than" | "less than or equal to" | "greater than or equal to" | "at most"
comparison: comparison_first "is"? comparison_operator comparison_second
!sum: "the total of"
!count: "the number of"
passive_aggregate: aggregate_operator string [string] [", in" ("a"|"an") string ","] "where" entity verb [entity]
!math_operator: "sum" | "difference" | "division" | "multiplication"
math: ("The" | "the") math_operator "between" math_first ", and" math_second
simple_proposition_with_entities: entity ("have" | "has" | "are" | "is")? verb list_of_entities
!negation: "not"
